# 해시
- 데이터 관리를 최적화 하기 위해 고안된 알고리즘 및 자료구조의 일종
- 빠른 데이터 접근 속도 : 해시 함수를 통해 생성된 해시값을 인덱스로 사용하면, 데이터의 저장 및 검색 속도가 매우 빨라짐
- 키-값 쌍(Key-Value Pair) : 해시는 키와 값을 연결하는 구조로, 키를 해시 함수에 입력하여 얻은 해시 값을 바탕으로 값을 저장하거나 검색

## JavaScript의 Map과 Set

- Map 객체 : (key, value) 쌍을 저장하며, 여기서 key는 유일해야함, 내부적으로 해시를 사용하여 키에 대한 빠른 접근을 제공
```jsx
let map = new Map();
map.set('name', 'John Doe');
console.log(map.get('name')); // 출력: John Doe
```

- Set 객체 : 중복되지 않는 유일한 값들을 저장, 내부적으로 해시를 사용하여 각 요소의 유일성을 보장
```jsx
let set = new Set([1, 2, 3, 2, 1]);
console.log(set); // 출력: Set {1, 2, 3}

```

## Java의 HashMap과 HashSet 

- HashMap : 키와 값을 저장하는 데 사용되며, 키는 유일, 내부적으로 해시 테이블 사용
```jsx
HashMap<String, String> map = new HashMap<>();
map.put("name", "John Doe");
System.out.println(map.get("name")); // 출력: John Doe

```

- HashSet : 중복 없이 요소를 저장하는 데 사용, 내부적으로 해시테이블을 사용하여 요소의 유일성 보장

```jsx
HashSet<Integer> set = new HashSet<>();
set.add(1); set.add(2); set.add(1);
System.out.println(set); // 출력: [1, 2]

```

</br>

ㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡ

</br>

## 폰켓몬

### 문제 설명
당신은 폰켓몬을 잡기 위한 오랜 여행 끝에, 홍 박사님의 연구실에 도착했습니다. 홍 박사님은 당신에게 자신의 연구실에 있는 총 N 마리의 폰켓몬 중에서 N/2마리를 가져가도 좋다고 했습니다.
홍 박사님 연구실의 폰켓몬은 종류에 따라 번호를 붙여 구분합니다. 따라서 같은 종류의 폰켓몬은 같은 번호를 가지고 있습니다. 예를 들어 연구실에 총 4마리의 폰켓몬이 있고, 각 폰켓몬의 종류 번호가 [3번, 1번, 2번, 3번]이라면 이는 3번 폰켓몬 두 마리, 1번 폰켓몬 한 마리, 2번 폰켓몬 한 마리가 있음을 나타냅니다. 이때, 4마리의 폰켓몬 중 2마리를 고르는 방법은 다음과 같이 6가지가 있습니다.

첫 번째(3번), 두 번째(1번) 폰켓몬을 선택
첫 번째(3번), 세 번째(2번) 폰켓몬을 선택
첫 번째(3번), 네 번째(3번) 폰켓몬을 선택
두 번째(1번), 세 번째(2번) 폰켓몬을 선택
두 번째(1번), 네 번째(3번) 폰켓몬을 선택
세 번째(2번), 네 번째(3번) 폰켓몬을 선택
이때, 첫 번째(3번) 폰켓몬과 네 번째(3번) 폰켓몬을 선택하는 방법은 한 종류(3번 폰켓몬 두 마리)의 폰켓몬만 가질 수 있지만, 다른 방법들은 모두 두 종류의 폰켓몬을 가질 수 있습니다. 따라서 위 예시에서 가질 수 있는 폰켓몬 종류 수의 최댓값은 2가 됩니다.
당신은 최대한 다양한 종류의 폰켓몬을 가지길 원하기 때문에, 최대한 많은 종류의 폰켓몬을 포함해서 N/2마리를 선택하려 합니다. N마리 폰켓몬의 종류 번호가 담긴 배열 nums가 매개변수로 주어질 때, N/2마리의 폰켓몬을 선택하는 방법 중, 가장 많은 종류의 폰켓몬을 선택하는 방법을 찾아, 그때의 폰켓몬 종류 번호의 개수를 return 하도록 solution 함수를 완성해주세요.

### 제한사항
nums는 폰켓몬의 종류 번호가 담긴 1차원 배열입니다.
nums의 길이(N)는 1 이상 10,000 이하의 자연수이며, 항상 짝수로 주어집니다.
폰켓몬의 종류 번호는 1 이상 200,000 이하의 자연수로 나타냅니다.
가장 많은 종류의 폰켓몬을 선택하는 방법이 여러 가지인 경우에도, 선택할 수 있는 폰켓몬 종류 개수의 최댓값 하나만 return 하면 됩니다.

### 입출력 예
|nums|	result|
|-|-|
|[3,1,2,3]	|2|
|[3,3,3,2,2,4]	|3|
|[3,3,3,2,2,2]	|2|


### 입출력 예 설명
입출력 예 #1
문제의 예시와 같습니다.

입출력 예 #2
6마리의 폰켓몬이 있으므로, 3마리의 폰켓몬을 골라야 합니다.
가장 많은 종류의 폰켓몬을 고르기 위해서는 3번 폰켓몬 한 마리, 2번 폰켓몬 한 마리, 4번 폰켓몬 한 마리를 고르면 되며, 따라서 3을 return 합니다.

입출력 예 #3
6마리의 폰켓몬이 있으므로, 3마리의 폰켓몬을 골라야 합니다.
가장 많은 종류의 폰켓몬을 고르기 위해서는 3번 폰켓몬 한 마리와 2번 폰켓몬 두 마리를 고르거나, 혹은 3번 폰켓몬 두 마리와 2번 폰켓몬 한 마리를 고르면 됩니다. 따라서 최대 고를 수 있는 폰켓몬 종류의 수는 2입니다.


```jsx
function solution(nums) {
    var answer = [];
    var max = nums.length / 2; // 선택할 수 있는 폰켓몬의 최대 개수를 저장하는 변수
    
    for(let i=0; i<nums.length; i++) {
        if(answer.length < max){ // answer 길이가 max보다 작은지 확인, 폰켓몬의 최대 개수를 초과하지 않는 조건 
            if(!answer.includes(nums[i])){ // 현재 순회 중인 폰켓몬의 종류(num[i])가 answer배열에 포함되어 있는지 확인
                answer.push(nums[i]) // 배열에 추가
            }
        }
    }
    return answer.length;
}


function solution(nums) {
    const pokemonTypes = new Set(nums); // Set을 사용하여 중복을 제거한 폰켓몬 종류 생성
    const maxSelect = nums.length / 2; // 선택할 수 있는 최대 폰켓몬 수
    return Math.min(pokemonTypes.size, maxSelect); // 가능한 폰켓몬 종류의 최댓값과 선택할 수 있는 최대 개수 중 더 작은 값을 반환
}
```

https://school.programmers.co.kr/learn/courses/30/lessons/1845





























